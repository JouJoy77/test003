"""
Дано:
Ресурс, предоставляющий доступ к закрытой информации после авторизации;
Сервис отправляющий СМС-сообщения.
Задача:
Разработать механизм авторизации пользователя с подтверждением по коду из СМС.
Требуется:
1. Описать схему работы Ресурса при взаимодействии с Пользователем.
2. Описать схему взаимодействия Ресурса с Сервисом.
3. Описать структуру моделей необходимых сущностей для хранения в БД
4. Составить примерный список необходимых для реализации инструментов и библиотек.

---------------------------------------------
Буду отталкиваться от того, что сервисы уже предоставлены и работают,
а моя задача - прикрутить механизм авторизации.
В таком случае, в зависимости от проекта, я бы предоставил код вроде того, что будет ниже.
Само собой, для разных фреймворков использование будет немного отличаться, но общие моменты есть.

---------------------------------------------
Пункты из "требуется":
1. Схема работы Ресурса при взаимодействии с Пользователем:
1.1. Пользователь посещает Ресурс и выбирает опцию "Авторизация".
1.2. Ресурс запрашивает у пользователя его номер мобильного телефона.
1.3. Ресурс генерирует код, заносит в БД, затем Сервис отправляет его пользователю.
1.4. Ресурс отображает форму для ввода кода из SMS.
1.5. Пользователь вводит код из SMS.
1.6. Ресурс проверяет код, введенный пользователем на совпадение с тем, что занесен в БД.
1.7. Если код верен и его срок давности (условные 5 минут) не истек - Ресурс предоставляет пользователю доступ.


2. Схема взаимодействия Ресурса с Сервисом:
2.1. Ресурс генерирует случайный код, после занесения в БД отправляет Сервису запрос на отправку SMS.
2.2. Сервис отправляет SMS на указанный номер телефона.


3. Структура моделей необходимых сущностей для хранения в БД:
User:
   - ID (уникальный идентификатор пользователя)
   - прочие дополнительные поля вроде ФИО, возраста и т.д. при необходимости - username.
   - Номер мобильного телефона
   - Код подтверждения
   - Дата занесения кода подтверждения в БД (дата генерации)
   - Хеш пароля (для безопасного хранения пароля)

На самом деле, можно завести отдельную модель для кодов, но здесь я не учитывал такое, чтобы не усложнять.
При ее наличии, она выглядела бы примерно так:

ConfirmationCode:
   - ID (уникальный идентификатор)
   - ID пользователя (связь с пользователем)
   - Код подтверждения
   - Дата занесения кода подтверждения в БД (дата генерации)
   - Флаг использования кода (при необходимости)


4. Примерный список необходимых инструментов и библиотек:
4.1. Фреймворк, например Flask или Django.
4.2. Библиотека для работы с БД, например SQLAlchemy/Django ORM в зависимости от фреймворка.
4.3. Сервис для отправки SMS: API, самописный модуль и т.д.
4.4. Библиотека для генерации случайных кодов, например random.
4.5. Механизм сессий или токенов для управления состоянием аутентификации пользователя.
4.6. Ресурсы для хранения пользовательских данных, например, PostgreSQL или SQLite БД.
4.7. Модуль datetime для работы с временными метками.
4.8. HttpResponse модуль для отправки ответа клиенту.

"""

# Здесь я импортирую функцию для получения токена для подключения к сервису.
# Импорт условный и зависит от проекта, требований к безопасности и т.д. safety_api - условный модуль,
# как и sms_service
from safety_api import get_sms_service_token
from sms_service import SMSService

# Здесь я импортирую модель для работы с БД. Например, пусть это будет аналогично Django моделям
from main.models import User

import random
from django.utils import timezone
from datetime import timedelta
from django.http import HttpResponse


def send_confirmation_code(phone_number, code):
    """
    Функция для отправки SMS с кодом.
    Подразумевается, что данная функция будет запущена при нажатии "отправить код",
    либо автоматически при попытке входа.

    Логика следующая - функция генерирует случайный код, например 6 цифр.
    В запись о пользователе в БД заносится информация: код и время его генерации
    (затем с этим временем будет проводится сравнение, что код еще актуален).
    Затем она дает команду сервису отправить СМС сообщение.
    На этом ее работа будет завершена.
    """
    # Здесь один из вариантов того, как можно взаимодействовать с сервисом.
    # В данном случае я создаю объект класса SMSService и предоставляю ему token,
    # Что даст мне возможность отправить методом этого класса СМС с кодом
    service = SMSService(token=get_sms_service_token())
    # Генерирую случайных 6-ти значный код
    code = random.randint(100000, 999999)
    # Получаю из БД нужного пользователя и меняю у него код подтверждения
    # Предполагается, что номер телефона уникален. Иначе нужно искать по ID или username
    user = User.objects.get(phone_number=phone_number)
    user.confirmation_code = code
    # Здесь предполагается, что проект настроен для UTC, в ином случае время нужно подводить под один стандарт
    user.code_timestamp = timezone.now()
    user.save()
    service.send_message(
        recipient=phone_number,
        text=f'Ваш код подтверждения: {code}'
    )


def verify_confirmation_code(phone_number, code):
    """
    Данная функция просто сравнивает введенный пользователем код с тем, что есть в БД.
    В случае успеха она возвращает (True, "Success"),
    В противном случае (False, {error_message}), которое можно будет показать пользователю,
    чтобы он мог понять - истек срок или код неверен.
    """
    user = User.objects.get(phone_number=phone_number)
    current_time = timezone.now()

    if user and current_time - user.code_timestamp > timedelta(minutes=5):
        return (False, "code expired")
    if user and user.confirmation_code == code:
        return (True, "success")
    return (False, "incorrect code")


def confirm_code_view(request):
    """
    Данная функция является примером того, как будет выглядеть view в django
    для подтверждения входа. Можно использовать redirect для перенаправления пользователя сразу
    на нужные страницы, можно использовать HttpResponce для отправки ответа,
    опять же в зависимости от приложения.
    P.S. Все же мне кажется, что здесь redirect не уместны и требуется сначала вернуть ответ.
    Поэтому я использовал HttpResponce. Затем уже другая функция может обработать этот ответ и
    перенаправлять пользователя.
    """
    if request.method == 'POST':
        phone_number = request.POST.get('phone_number')
        code = request.POST.get('confirmation_code')
        success, message = verify_confirmation_code(phone_number, code)
        if success:
            return HttpResponse(message, status=200)
        return HttpResponse(message, status=400)
